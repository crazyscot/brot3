// Copyright Â© SixtyFPS GmbH <info@slint.dev>
// SPDX-License-Identifier: MIT

import { Slider, Button, VerticalBox, HorizontalBox } from "std-widgets.slint";
import { InfoDisplayData, InfoDisplay } from "info.slint";

export struct Tile { x: length, y: length, tile: image}

export component MainUI inherits Window {
    callback flicked(length, length);
    callback zoom-changed(float);
    callback zoom-in(length, length);
    callback zoom-out(length, length);
    callback resegment-clicked();

    // Window sizing callback. This returns a dummy invisible image but triggers the logic to reconsider the visible tiles.
    pure callback resized(length, length) -> image;
    min-height: 500px;
    min-width: 500px;

    out property <length> visible_width <=> fli.width;
    out property <length> visible_height <=> fli.height;

    default-font-family: "Inter";

    in-out property <float> zoom <=> sli.value;
    in property <float> minimum-zoom <=> sli.minimum;

    in property <[Tile]> tiles;

    in property <string> window-title <=> self.title;

    out property <length> viewport-x <=> fli.viewport-x;
    out property <length> viewport-y <=> fli.viewport-y;

    // ox,oy: Viewport offsets within the visible segment (these are usually negative?)
    // width, height: viewport size
    public function set_viewport(ox: length, oy: length, width: length, height: length) {
        fli.viewport-x = ox;
        fli.viewport-y = oy;
        fli.viewport-width = width;
        fli.viewport-height = height;
    }

    VerticalLayout {
        fli := Flickable {
            for t in tiles: Image {
                x: t.x;
                y: t.y;
                source: t.tile;
            }
            flicked => {
                root.flicked(fli.viewport-x, fli.viewport-y);
            }
            TouchArea {
                scroll-event(e) => {
                    if e.delta-y > 0 {
                        root.zoom-in(self.mouse-x + fli.viewport-x, self.mouse-y + fli.viewport-y);
                        return accept;
                    } else if e.delta-y < 0 {
                        root.zoom-out(self.mouse-x + fli.viewport-x, self.mouse-y + fli.viewport-y);
                        return accept;
                    }
                    return reject;
                }
            }
        }

        HorizontalLayout {
            sli := Slider {
                minimum: 1; // initial value (UI_MIN_ZOOM_LEVEL); may be updated dynamically
                maximum: 45; // !!! Must match UI_MAX_ZOOM_LEVEL
                released => {
                    zoom-changed(self.value);
                }
            }
        }
    }

    /*
    btn := Button { // TECHDEBT This was put in for testing resegmentation; should be made automatic.
        x: 0;
        y: fli.y + (fli.height) - (self.height) - 3px;
        text: "Resegment";
        clicked => {
            root.resegment-clicked();
        }
    }
    */

    in property <InfoDisplayData> info_data;
    hud := InfoDisplay {
        data <=> info_data;
        // Position over the bottom of the fractal viewport
        x: 0;
        y: fli.y + fli.height - self.height;
    }

    dummy_img := Image {
        source: resized(root.width, root.height);
    }
}
